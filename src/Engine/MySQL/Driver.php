<?php

namespace Castor\Tabloid\Engine\MySQL;

use Castor\Tabloid\Metadata\Field;
use Castor\Tabloid\Metadata;
use Castor\Tabloid\Metadata\ValidationError;
use Castor\Tabloid\Metadata\Validator;
use Castor\Tabloid\SQL\Connection;
use Castor\Tabloid\SQL\ConnectionError;
use Castor\Tabloid\SQL\OperationError;
use Castor\Tabloid\SQL\Type;
use Castor\Tabloid\Transactional;

final class Driver implements Connection, Validator, Type\Registry, Transactional
{
    public const VER_57 = 57;
    public const VER_80 = 80;
    /**
     * @var Connection The underlying connection for this driver
     */
    private Connection $conn;
    private Types $types;
    /**
     * @var int The MySQL version for this driver
     */
    private int $version;

    /**
     * @param Connection $conn
     * @param Types $types
     * @param int $version
     */
    public function __construct(Connection $conn, Types $types, int $version = self::VER_57)
    {
        $this->conn = $conn;
        $this->types = $types;
        $this->version = $version;
    }

    /**
     * @param string $query
     * @param array $params
     * @return int
     * @throws ConnectionError
     * @throws OperationError
     */
    public function execute(string $query, array $params = []): int
    {
        return $this->conn->execute($query, $params);
    }

    public function query(string $query, array $params = []): iterable
    {
        return $this->conn->query($query, $params);
    }

    public function lastInsertedId(): string
    {
        return $this->conn->lastInsertedId();
    }

    /**
     * @inheritDoc
     */
    public function get(string $type): Type
    {
        return $this->types->get($type);
    }

    /**
     * @inheritDoc
     */
    public function validate(Metadata ...$metas): void
    {
        foreach ($metas as $meta) {
            try {
                $table = $this->describeTable($meta->getTable()->getName());
            } catch (ConnectionError | OperationError $e) {
                throw ValidationError::general($meta->getClass()->getName(), $e->getMessage());
            }

            $err = static function (Field $field, string $reason) use ($meta): ValidationError {
                return new ValidationError(sprintf(
                    'Validation error on metadata of class %s: column "%s" of table "%s" (mapped by property "%s") %s',
                    $meta->getClass()->getName(),
                    $field->getColumn()->getName(),
                    $meta->getTable()->getName(),
                    $field->getName(),
                    $reason
                ));
            };

            foreach ($meta->getFields() as $field) {
                $col = $table[$field->getColumn()->getName()] ?? null;
                if (!$col instanceof ColumnInfo) {
                    throw $err($field, 'does not exist in the database');
                }
                $type = $field->getType();
                if ($type instanceof BaseType && !$type->isValidDatabaseType($col->getTypeName())) {
                    throw $err($field, sprintf(
                        'database type "%s" is invalid for mapping type "%s"',
                        $col->getTypeName(),
                        get_class($type)
                    ));
                }
                if ($field->getColumn()->isPrimaryKey() && !$col->isPrimaryKey()) {
                    throw $err($field, 'is marked as primary key but in the database is not');
                }
                if (!$field->getColumn()->isPrimaryKey() && $col->isPrimaryKey()) {
                    throw $err($field, 'is not marked as primary key but in the database it is');
                }
                if ($field->getColumn()->isNullable() && !$col->isNullable()) {
                    throw $err($field, 'is marked as nullable but in the database is not');
                }
                if (!$field->getColumn()->isNullable() && $col->isNullable()) {
                    throw $err($field, 'is not marked as nullable but in the database it is');
                }
                if ($field->getColumn()->isAutogenerated() && !$col->isAutoincrement()) {
                    throw $err($field, 'is marked as autogenerated but in the database is not autoincrementable');
                }
                if (!$field->getColumn()->isAutogenerated() && $col->isAutoincrement()) {
                    throw $err($field, 'is not marked as autogenerated but in the database is autoincrementable');
                }
            }
        }
    }

    /**
     * @param string $table
     * @return array<string,ColumnInfo>
     * @throws ConnectionError
     * @throws OperationError
     */
    public function describeTable(string $table): array
    {
        $info = [];
        $rows = $this->conn->query("DESCRIBE `$table`");
        foreach ($rows as $row) {
            $col = ColumnInfo::parse($row);
            $info[$col->getName()] = $col;
        }
        return $info;
    }

    /**
     * @param callable $operation
     * @return mixed
     */
    public function wrapInTransaction(callable $operation): mixed
    {
        if ($this->conn instanceof Transactional) {
            return $this->conn->wrapInTransaction($operation);
        }
        return null;
    }

    /**
     * @return int
     */
    public function getVersion(): int
    {
        return $this->version;
    }
}